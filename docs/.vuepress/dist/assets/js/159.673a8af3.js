(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{532:function(t,e,n){"use strict";n.r(e),n.d(e,"renderer",(function(){return pt}));var o=n(393),i=n(525),a=n(524);class r extends o.o{constructor(){const t=r.SkyShader,e=new o.u({name:"SkyShader",fragmentShader:t.fragmentShader,vertexShader:t.vertexShader,uniforms:o.x.clone(t.uniforms),side:o.b,depthWrite:!1});super(new o.c(1,1,1),e),this.isSky=!0}}r.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new o.z},up:{value:new o.z(0,1,0)}},vertexShader:"\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",fragmentShader:"\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"};n(13),n(446),n(447),n(448),n(449),n(450),n(451),n(452);var s="\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n\n// https://github.com/mrdoob/three.js/pull/22425\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\n\n// 设置透明度变化\nfloat r = distance(gl_PointCoord, vec2(0.5, 0.5));\n// diffuseColor.a = diffuseColor.a*(1.0 - r/0.5);//透明度线性变化\ndiffuseColor.a = diffuseColor.a*pow( 1.0 - r/0.5, 2.0 );//透明度非线性变化  参数2越大，gl_PointSize要更大，可以直接设置着色器代码，可以设置材质size属性\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",l=new o.i,c=new o.e,d=new o.z(9e3,-6e3,-1e4),v=new o.z(-3e3,-3e3,4e3),f=new o.l(d,v).getSpacedPoints(3e3).map(t=>new o.z(t.x,t.y,t.z));c.setFromPoints(f);var u=new o.k({color:26214}),g=(new o.j(c,u),0),h=f.slice(g,g+300),p=new o.f(h).getSpacedPoints(100),m=new o.e;m.setFromPoints(p);for(var w=[],S=0;S<p.length;S++)w.push(S/p.length);var x=new o.d(new Float32Array(w),1);m.attributes.percent=x;var y=[];for(S=0;S<p.length;S++){var P=new o.g(16777215),z=new o.g(52428),C=P.lerp(z,S/p.length);y.push(C.r,C.g,C.b)}m.attributes.color=new o.d(new Float32Array(y),3);var E=new o.r({size:60,vertexColors:!0,transparent:!0,depthTest:!1}),b=new o.q(m,E);l.add(b),E.onBeforeCompile=function(t){t.vertexShader=t.vertexShader.replace("void main() {",["attribute float percent;","void main() {"].join("\n")),t.vertexShader=t.vertexShader.replace("gl_PointSize = size;",["gl_PointSize = percent * size;"].join("\n")),t.fragmentShader=t.fragmentShader.replace("#include <output_fragment>",s)},l.rotation.x=o.n.degToRad(90);var R=f.length-300;!function t(){g>R&&(g=0),g+=5,h=f.slice(g,g+300);var e=new o.f(h).getSpacedPoints(100);m.setFromPoints(e),requestAnimationFrame(t)}();var T=new o.i,F=new o.e,A=new o.z(9e3,-5e3,-1e4),_=new o.z(-8e3,-2e3,5e3),M=new o.l(A,_).getSpacedPoints(3e3).map(t=>new o.z(t.x,t.y,t.z));F.setFromPoints(M);var B=new o.k({color:26214}),D=(new o.j(F,B),0),k=M.slice(D,D+200),j=new o.f(k).getSpacedPoints(100),L=new o.e;L.setFromPoints(j);for(var I=[],O=0;O<j.length;O++)I.push(O/j.length);var W=new o.d(new Float32Array(I),1);L.attributes.percent=W;var N=[];for(O=0;O<j.length;O++){var q=new o.g(16777215),G=new o.g(52428),H=q.lerp(G,O/j.length);N.push(H.r,H.g,H.b)}L.attributes.color=new o.d(new Float32Array(N),3);var V=new o.r({size:60,vertexColors:!0,transparent:!0,depthTest:!1}),Z=new o.q(L,V);T.add(Z),V.onBeforeCompile=function(t){t.vertexShader=t.vertexShader.replace("void main() {",["attribute float percent;","void main() {"].join("\n")),t.vertexShader=t.vertexShader.replace("gl_PointSize = size;",["gl_PointSize = percent * size;"].join("\n")),t.fragmentShader=t.fragmentShader.replace("#include <output_fragment>",s)},T.rotation.x=o.n.degToRad(90);var K=M.length-200;!function t(){D>K&&(D=0),D+=5,k=M.slice(D,D+200);var e=new o.f(k).getSpacedPoints(100);L.setFromPoints(e),requestAnimationFrame(t)}();var U=new o.i,J=new o.e,X=new o.z(9e3,-6e3,-1e4),Q=new o.z(-3650,4e3,4e3),Y=new o.l(X,Q).getSpacedPoints(3e3).map(t=>new o.z(t.x,t.y,t.z));J.setFromPoints(Y);var $=new o.k({color:26214}),tt=(new o.j(J,$),0),et=Y.slice(tt,tt+300),nt=new o.f(et).getSpacedPoints(100),ot=new o.e;ot.setFromPoints(nt);for(var it=[],at=0;at<nt.length;at++)it.push(at/nt.length);var rt=new o.d(new Float32Array(it),1);ot.attributes.percent=rt;var st=[];for(at=0;at<nt.length;at++){var lt=new o.g(16777215),ct=new o.g(3407871),dt=lt.lerp(ct,at/nt.length);st.push(dt.r,dt.g,dt.b)}ot.attributes.color=new o.d(new Float32Array(st),3);var vt=new o.r({size:60,vertexColors:!0,transparent:!0,depthTest:!1}),ft=new o.q(ot,vt);U.add(ft),vt.onBeforeCompile=function(t){t.vertexShader=t.vertexShader.replace("void main() {",["attribute float percent;","void main() {"].join("\n")),t.vertexShader=t.vertexShader.replace("gl_PointSize = size;",["gl_PointSize = percent * size;"].join("\n")),t.fragmentShader=t.fragmentShader.replace("#include <output_fragment>",s)},U.rotation.x=o.n.degToRad(90);var ut=Y.length-300;let gt,ht,pt,mt,wt;function St(){gt.aspect=window.innerWidth/window.innerHeight,gt.updateProjectionMatrix(),pt.setSize(window.innerWidth,window.innerHeight),xt()}function xt(){pt.render(ht,gt),requestAnimationFrame(xt)}!function t(){tt>ut&&(tt=0),tt+=5,et=Y.slice(tt,tt+300);var e=new o.f(et).getSpacedPoints(100);ot.setFromPoints(e),requestAnimationFrame(t)}(),function(){gt=new o.p(50,window.innerWidth/window.innerHeight,100,2e6),gt.position.set(-658.8798162982844,-708.8756101152045,1753.103749656179),ht=new o.t,pt=new o.A,pt.setPixelRatio(window.devicePixelRatio),pt.setSize(window.innerWidth,window.innerHeight),pt.outputEncoding=o.B,pt.toneMapping=o.a,pt.toneMappingExposure=.5;const t=new i.a(gt,pt.domElement);t.enableZoom=!1,t.enablePan=!1,function(){mt=new r,mt.scale.setScalar(45e4),ht.add(mt),wt=new o.z;const t={turbidity:0,rayleigh:.15,mieCoefficient:.005,mieDirectionalG:.7,elevation:2,azimuth:180,exposure:pt.toneMappingExposure};function e(){const e=mt.material.uniforms;e.turbidity.value=t.turbidity,e.rayleigh.value=t.rayleigh,e.mieCoefficient.value=t.mieCoefficient,e.mieDirectionalG.value=t.mieDirectionalG;const n=o.n.degToRad(90-t.elevation),i=o.n.degToRad(t.azimuth);wt.setFromSphericalCoords(1,n,i),e.sunPosition.value.copy(wt),pt.toneMappingExposure=t.exposure,pt.render(ht,gt)}const n=new a.a;console.log(n),n.add(t,"turbidity",0,20,.1).onChange(e),n.add(t,"rayleigh",0,4,.001).onChange(e),n.add(t,"mieCoefficient",0,.1,.001).onChange(e),n.add(t,"mieDirectionalG",0,1,.001).onChange(e),n.add(t,"elevation",0,90,.1).onChange(e),n.add(t,"azimuth",-180,180,.1).onChange(e),n.add(t,"exposure",0,1,1e-4).onChange(e),e(),n.domElement.style.display="none"}(),window.addEventListener("resize",St)}(),xt(),ht.add(l),ht.add(T),ht.add(U)}}]);